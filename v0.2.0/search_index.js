var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "Inpaintings.jl Documentation",
    "title": "Inpaintings.jl Documentation",
    "category": "page",
    "text": ""
},

{
    "location": "#Inpaintings.jl-Documentation-1",
    "page": "Inpaintings.jl Documentation",
    "title": "Inpaintings.jl Documentation",
    "category": "section",
    "text": "Inpaintings.jl provides functions that perform a similar task to MATLAB\'s inpaint_nans function.  (MATLAB\'s inpaint_nans was originally written by John d\'Errico and is available on the MathWorks File Exchange website.)inpaint_nans takes a vector or a matrix as input and fills (\"inpaints\") the NaNs by solving a simple 1D or 2D PDE.So far Inpaintings.jl only replicates John d\'Errico\'s method 0 well, which is well suited for filling NaNs in a \"diffusive\" way. Methods 1 and 3 are on their way. Other methods will come next."
},

{
    "location": "#Usage-1",
    "page": "Inpaintings.jl Documentation",
    "title": "Usage",
    "category": "section",
    "text": "Use the package as you would any Julia packageDocTestSetup = quote\n    using Inpaintings\nendThe command inpaint_nans(A) will fill the NaNs of an Array A (that has some NaNs):# Making a test matrix A with some NaNs by replacing values from fullA\nn = 10\nfullA = float(collect(1:n) * collect(1:n)\')\nA = copy(fullA)\nA[1:5, 1:5] .= NaN # replace some values with some NaNs\nB = inpaint(A, NaN)\nB ≈ fullA\n\n# output\n\ntrue"
},

{
    "location": "#Inpaintings.inpaint-Tuple{Any,Any}",
    "page": "Inpaintings.jl Documentation",
    "title": "Inpaintings.inpaint",
    "category": "method",
    "text": "inpaint(f, A)\n\nInpaints values of A for which f(A) == true.\n\nExamples\n\njulia> A = float((1:5)*(1:5)\') ; A[1:2, 1:2] .= 999 ; A\n5×5 Array{Float64,2}:\n 999.0  999.0   3.0   4.0   5.0\n 999.0  999.0   6.0   8.0  10.0\n   3.0    6.0   9.0  12.0  15.0\n   4.0    8.0  12.0  16.0  20.0\n   5.0   10.0  15.0  20.0  25.0\n\njulia> inpaint(x -> x == 999, A)\n5×5 Array{Float64,2}:\n 1.0   2.0   3.0   4.0   5.0\n 2.0   4.0   6.0   8.0  10.0\n 3.0   6.0   9.0  12.0  15.0\n 4.0   8.0  12.0  16.0  20.0\n 5.0  10.0  15.0  20.0  25.0\n\njulia> A = float((1:5)*(1:5)\') ; A[1:2, [1, end]] .= NaN ; A\n5×5 Array{Float64,2}:\n NaN     2.0   3.0   4.0  NaN\n NaN     4.0   6.0   8.0  NaN\n   3.0   6.0   9.0  12.0   15.0\n   4.0   8.0  12.0  16.0   20.0\n   5.0  10.0  15.0  20.0   25.0\n\njulia> inpaint(isnan, A)\n5×5 Array{Float64,2}:\n 1.0   2.0   3.0   4.0   5.0\n 2.0   4.0   6.0   8.0  10.0\n 3.0   6.0   9.0  12.0  15.0\n 4.0   8.0  12.0  16.0  20.0\n 5.0  10.0  15.0  20.0  25.0\n\ninpaint(f, A; method=1, cycledims=[])\n\nWith optional arguments, you can chose the inpainting method and if dimensions are cyclic.\n\njulia> A = float((1:5)*(1:5)\') ; A[1:2, [1, end]] .= NaN ; A\n5×5 Array{Float64,2}:\n NaN     2.0   3.0   4.0  NaN\n NaN     4.0   6.0   8.0  NaN\n   3.0   6.0   9.0  12.0   15.0\n   4.0   8.0  12.0  16.0   20.0\n   5.0  10.0  15.0  20.0   25.0\n\njulia> inpaint(A, cycledims=[2])\n5×5 Array{Float64,2}:\n 2.13971   2.0   3.0   4.0   3.86029\n 3.50735   4.0   6.0   8.0   8.49265\n 3.0       6.0   9.0  12.0  15.0\n 4.0       8.0  12.0  16.0  20.0\n 5.0      10.0  15.0  20.0  25.0\n\n\n\n\n\n"
},

{
    "location": "#Inpaintings.inpaint-Tuple{Union{Array{T,1}, Array{T,2}} where T,Missing}",
    "page": "Inpaintings.jl Documentation",
    "title": "Inpaintings.inpaint",
    "category": "method",
    "text": "inpaint(A, missing)\n\nInpaints missing values. Should be the same as inpaint(A).\n\n\n\n\n\n"
},

{
    "location": "#Inpaintings.inpaint-Union{Tuple{T}, Tuple{Union{Array{T,1}, Array{T,2}},Any}} where T<:AbstractFloat",
    "page": "Inpaintings.jl Documentation",
    "title": "Inpaintings.inpaint",
    "category": "method",
    "text": "inpaint(A, value_to_fill)\n\nInpaints value_to_fill values (can be NaN). Useful in the case data was generated by filling missing values with an arbitrary chosen one.\n\nExamples\n\njulia> A = float((1:5)*(1:5)\') ; A[1:2, 1:2] .= 999 ; A\n5×5 Array{Float64,2}:\n 999.0  999.0   3.0   4.0   5.0\n 999.0  999.0   6.0   8.0  10.0\n   3.0    6.0   9.0  12.0  15.0\n   4.0    8.0  12.0  16.0  20.0\n   5.0   10.0  15.0  20.0  25.0\n\njulia> inpaint(A, 999)\n5×5 Array{Float64,2}:\n 1.0   2.0   3.0   4.0   5.0\n 2.0   4.0   6.0   8.0  10.0\n 3.0   6.0   9.0  12.0  15.0\n 4.0   8.0  12.0  16.0  20.0\n 5.0  10.0  15.0  20.0  25.0\n\njulia> A = float((1:5)*(1:5)\') ; A[1:2, 1:2] .= NaN ; A\n5×5 Array{Float64,2}:\n NaN    NaN     3.0   4.0   5.0\n NaN    NaN     6.0   8.0  10.0\n   3.0    6.0   9.0  12.0  15.0\n   4.0    8.0  12.0  16.0  20.0\n   5.0   10.0  15.0  20.0  25.0\n\njulia> inpaint(A, NaN)\n5×5 Array{Float64,2}:\n 1.0   2.0   3.0   4.0   5.0\n 2.0   4.0   6.0   8.0  10.0\n 3.0   6.0   9.0  12.0  15.0\n 4.0   8.0  12.0  16.0  20.0\n 5.0  10.0  15.0  20.0  25.0\n\n\n\n\n\n"
},

{
    "location": "#Inpaintings.inpaint-Union{Tuple{Union{Array{T,1}, Array{T,2}}}, Tuple{T}} where T<:AbstractFloat",
    "page": "Inpaintings.jl Documentation",
    "title": "Inpaintings.inpaint",
    "category": "method",
    "text": "inpaint(A)\n\nInpaints NaN values if the elements of A are all float (i.e., eltype(A) <: AbstractFloat).\n\nExample\n\njulia> A = float((1:5)*(1:5)\') ; A[1:2, 1:2] .= NaN ; A\n5×5 Array{Float64,2}:\n NaN    NaN     3.0   4.0   5.0\n NaN    NaN     6.0   8.0  10.0\n   3.0    6.0   9.0  12.0  15.0\n   4.0    8.0  12.0  16.0  20.0\n   5.0   10.0  15.0  20.0  25.0\n\njulia> inpaint(A)\n5×5 Array{Float64,2}:\n 1.0   2.0   3.0   4.0   5.0\n 2.0   4.0   6.0   8.0  10.0\n 3.0   6.0   9.0  12.0  15.0\n 4.0   8.0  12.0  16.0  20.0\n 5.0  10.0  15.0  20.0  25.0\n\n\n\n\n\n"
},

{
    "location": "#Inpaintings.inpaint-Union{Tuple{Union{Array{Union{Missing, T},1}, Array{Union{Missing, T},2}}}, Tuple{T}} where T<:AbstractFloat",
    "page": "Inpaintings.jl Documentation",
    "title": "Inpaintings.inpaint",
    "category": "method",
    "text": "inpaint(A)\n\nInpaints missing values if A contains some.\n\nInspired by MATLAB\'s inpaint_nans\'s (by John d\'Errico: link).\n\nExample\n\njulia> A = convert(Array{Union{Float64, Missing},2}, (1:5)*(1:5)\') ; A[1:2, 1:2] .= missing ; A\n5×5 Array{Union{Missing, Float64},2}:\n  missing    missing   3.0   4.0   5.0\n  missing    missing   6.0   8.0  10.0\n 3.0        6.0        9.0  12.0  15.0\n 4.0        8.0       12.0  16.0  20.0\n 5.0       10.0       15.0  20.0  25.0\n\njulia> inpaint(A)\n5×5 Array{Union{Missing, Float64},2}:\n 1.0   2.0   3.0   4.0   5.0\n 2.0   4.0   6.0   8.0  10.0\n 3.0   6.0   9.0  12.0  15.0\n 4.0   8.0  12.0  16.0  20.0\n 5.0  10.0  15.0  20.0  25.0\n\n\n\n\n\n"
},

{
    "location": "#Inpaintings.inpaint_method0-Tuple{Any,Array{T,1} where T}",
    "page": "Inpaintings.jl Documentation",
    "title": "Inpaintings.inpaint_method0",
    "category": "method",
    "text": "inpaint_method0(f, A::Vector)\n\nInpaints values in A that f gives true on by solving a simple diffusion PDE. The partial differential equation (PDE) is defined by the standard Laplacian, Δ = ∇^2. Inspired by MATLAB\'s inpaint_nans\'s method 0 for vectors (by John d\'Errico). See https://www.mathworks.com/matlabcentral/fileexchange/4551-inpaint_nans.\n\n\n\n\n\n"
},

{
    "location": "#Inpaintings.inpaint_method1-Tuple{Any,Array}",
    "page": "Inpaintings.jl Documentation",
    "title": "Inpaintings.inpaint_method1",
    "category": "method",
    "text": "inpaint_method1(f, A::Array, cycledims=Int64[])\n\nInpaints values in A that f gives true on by solving a simple diffusion PDE. Default method for inpaint. The partial differential equation (PDE) is defined by the standard Laplacian, Δ = ∇^2. Inspired by MATLAB\'s inpaint_nans\'s method 0 for matrices (by John d\'Errico). See https://www.mathworks.com/matlabcentral/fileexchange/4551-inpaint_nans. The discrete stencil used for Δ looks like\n\n      ┌───┐\n      │ 1 │\n      └─┬─┘\n        │\n┌───┐ ┌─┴─┐ ┌───┐\n│ 1 ├─┤-4 ├─┤ 1 │\n└───┘ └─┬─┘ └───┘\n        │\n      ┌─┴─┐\n      │ 1 │\n      └───┘\n\nBy default, the stencil is not applied at the borders. Instead, its 1D component,\n\n┌───┐ ┌───┐ ┌───┐\n│ 1 ├─┤-2 ├─┤ 1 │\n└───┘ └───┘ └───┘\n\nis applied where it fits at the borders. However, the user can supply a list of dimensions that should be considered cyclic. In this case, the sentil will be used also at the borders and \"jump\" to the other side. This is particularly useful for, e.g., world maps with longitudes spanning the entire globe.\n\n\n\n\n\n"
},

{
    "location": "#Inpaintings.list_neighbors-Tuple{Any,Any,Any}",
    "page": "Inpaintings.jl Documentation",
    "title": "Inpaintings.list_neighbors",
    "category": "method",
    "text": "list_neighbors(A, idx, neighbors)\n\nLists all the neighbors of the indices in idx in Array A. Neighbors already in idx are accepted. The argument neighnors contains a list of the neighbors about the origin coordinate (0, 0, ...). In other words, it is a Vector of CartesianIndex such that the direct neighbors of index i are given by i + n for n in neighbors. Inspired by MATLAB\'s inpaint_nans\'s identify_neighbors (by John d\'Errico). See https://www.mathworks.com/matlabcentral/fileexchange/4551-inpaint_nans.\n\n\n\n\n\n"
},

{
    "location": "#Functions-1",
    "page": "Inpaintings.jl Documentation",
    "title": "Functions",
    "category": "section",
    "text": "Modules = [Inpaintings]\nOrder   = [:function, :type]"
},

]}
